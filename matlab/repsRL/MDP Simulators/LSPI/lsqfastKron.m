function [w, A, b] = lsqfastKron(samples, policy, new_policy, firsttime)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Copyright 2000-2002%% Michail G. Lagoudakis (mgl@cs.duke.edu)% Ronald Parr (parr@cs.duke.edu)%% Department of Computer Science% Box 90129% Duke University, NC 27708%% Copyright 2006% Mauro Maggioni (mauro@math.duke.edu)%% Jeff Johns  02/22/2007    (johns@cs.umass.edu)%% I updated the lsqfast code to work in "batch" mode.% lsq.m computes matrices A and b by iterating through each sample.% lsqfast.m speeds up this computation by vectorizing the code.% Instead of going through sample by sample like lsq.m, it forms% matrices and uses matrix multiplication to compute A and b.% lsqfast.m creates matrices of size [N]x[k] where N is the number% of samples and k is the number of eigenvectors times the number% of actions.  These matrices can be very large when N gets big.% This function is a compromise between the two extremes and% lets the user control the memory usage explicitly.  The matrices% formed here are of size [batchSize]x[k] where the user can% specify batchSize.%% The lsq algorithm evaluates the "policy" using the set of "samples",% that is, it learns a set of weights for the basis specified in% new_policy to form the approximate Q-value of the "policy" and the% improved "new_policy". The approximation is the fixed point of the% Bellman equation.%% "firsttime" is a flag (0 or 1) to indicate whether this is the first% time this set of samples is processed. Preprossesing of the set is% triggered if "firstime"==1.%% Returns the learned weights w and the matrices A and b of the% linear system Aw=b.%% See also lsq.m for a slower (incremental) implementation, and% lsqfast.m for a faster but potentially more memory intensive% implementation.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%fNameRhat   = 'initRhat.dat';fNamePhihat = 'initPhihat.dat';batchSize   = 10000;% Process all variables that have dimension "# samples" in batcheshowmany = length(samples);k = feval(new_policy.basis);A = zeros(k, k);b = zeros(k, 1);mytime = cputime;numBatches = ceil(howmany / batchSize);%%% Precompute Phihat and Rhat for all subsequent iterationsif firsttime == 1    fidR = fopen(fNameRhat, 'w');    fidP = fopen(fNamePhihat, 'w');    for i=1:numBatches        batchInit = (i-1)*batchSize + 1;        batchEnd  = min(i*batchSize, howmany);        Rhat_i    = cat(1, samples(batchInit:batchEnd).reward);        Phihat_i  = feval(new_policy.basis, (batchInit:batchEnd)', cat(1,samples(batchInit:batchEnd).action));        % Save the data%        if (i==1)%            dlmwrite(fNameRhat, Rhat_i);                    % dimension [batch]x[1]%            dlmwrite(fNamePhihat, Phihat_i');               % dimension [batch]x[numEigs*numActions]%        else%            dlmwrite(fNameRhat, Rhat_i, '-append');         % dimension [batch]x[1]%            dlmwrite(fNamePhihat, Phihat_i', '-append');    % dimension [batch]x[numEigs*numActions]%        end        fwrite(fidR, Rhat_i, 'double');             % [batch]x[1]        fwrite(fidP, Phihat_i, 'double');           % [numEigs*numActions]x[batch]        clear Rhat_i;        clear Phihat_i;    end    fclose(fidR);    fclose(fidP);end% Form matrices A and b in batchesfor i=1:numBatches    batchInit = (i-1)*batchSize + 1;    batchEnd  = min(i*batchSize, howmany);    % Read in the data from Rhat and Phihat%    Rhat_i   = dlmread(fNameRhat, ',', [(batchInit-1) 0 (batchEnd-1) 0]);%    Phihat_i = dlmread(fNamePhihat, ',', [(batchInit-1) 0 (batchEnd-1) (k-1)]);    fidR = fopen(fNameRhat, 'r');    fseek(fidR, (batchInit-1)*8, 'cof');    Rhat_i = fread(fidR, (batchEnd-batchInit+1), 'double');    fclose(fidR);    fidP = fopen(fNamePhihat, 'r');    fseek(fidP, (batchInit-1)*k*8, 'cof');    Phihat_i = fread(fidP, (batchEnd-batchInit+1)*k, 'double');    Phihat_i = reshape(Phihat_i, k, (batchEnd-batchInit+1));    fclose(fidP);    % Evaluate the basis functions at the states and actions in nextsample's    lNotAbsorbIdxs_i = find(~cat(1,samples(batchInit:batchEnd).absorb));    lNotAbsorbIdxs_i = lNotAbsorbIdxs_i + (batchInit - 1);    if (i == numBatches)        lNextStates_i = setdiff(lNotAbsorbIdxs_i, length(samples));    else        lNextStates_i = lNotAbsorbIdxs_i;    end    clear lNotAbsorbIdxs_i;    % Compute the basis functions from the optimal action at the next state    [optActions, nextphi_i] = policy_function(policy, lNextStates_i+1);    clear optActions;    % Compute PiPhihat    PiPhihat_i = zeros( (batchEnd-batchInit+1), k );    PiPhihat_i( (lNextStates_i - (batchInit - 1)), :) = nextphi_i';    clear lNextStates_i;    clear nextphi_i;    % Update matrices A and b    if (i==1)        A = Phihat_i * (Phihat_i' - new_policy.discount * PiPhihat_i);        b = Phihat_i * Rhat_i;    else        A = A + Phihat_i * (Phihat_i' - new_policy.discount * PiPhihat_i);        b = b + Phihat_i * Rhat_i;    end    % Clear out important variables    clear Rhat_i;    clear Phihat_i;    clear PiPhihat_i;end% phi_time = cputime - mytime;% % disp(['CPU time to form A and b : ' num2str(phi_time)]);% % mytime = cputime;% %%% Solve the system to find wif true,    % Standard inversion.    % Use least squares \ or pinv depending on whether A is badly conditioned or not    % TODO: one can gain a factor of 2 when pinv is used, since here both rank and pinv use the full svd%     rankA = rank(A);% % % %     rank_time = cputime - mytime;% %     disp(['CPU time to find the rank of A : ' num2str(phi_time)]);% %     mytime = cputime;% % % %     disp(['Rank of matrix A : ' num2str(rankA)]);% %     if rankA==k% %         disp('A is full rank.');%         w = A\b;% %     else% %         disp(['A is lower rank. Should be ' num2str(k)]);%         w = pinv(A)*b;%     end%     solve_time = cputime - mytime;% %     disp(['CPU time to solve Aw=b : ' num2str(solve_time)]);else    % Multiscale inversion. The matrix T w.r.t which the multiscale structure is constructed is    % new_policy.discount*(Phihat*Phihat')^{-1}*Phihat*PiPhihat    % TODO: (Phihat*Phihat')^{-1}*Phihat does not change through iterations, so it could be computed once for all    % This will not work when norm(Pnew)>1 (or, in practice, norm(Pnew)>~1.4, and there aren't more than 12 or so levels)        B=Phihat*Phihat';Binv=pinv(B);        Pnew=new_policy.discount*Binv*Phihat*PiPhihat;        norm(Pnew),    %figure;subplot(1,2,1);plot(log10(svd(B)));subplot(1,2,2);plot(log10(svd(Pnew)));    bnew=Binv*b;    w = DWSolveLinearSystem( Pnew, bnew, struct('Type','Normal','Precision',1e-6,'Reorthogonalize',true,'Threshold',1e-6,'IPThreshold',1e-12) );    % For debug purposes only:    % fprintf('Operator norm of Pnew:%f',norm(Pnew));   % Check if the norm of Pnew was too large...catastrophic effects will already been seen though!    w1 = pinv(eye(size(Pnew))-Pnew)*bnew;             % Solve with pinv    fprintf('Norm of difference between multiscale and svd solution: %f\n',norm(w-w1));   % Compare the solution of pinv with the one of DWSolveLinearSystemend;return;