function NeuroSimulator(architecture, typeStimuli, typeNeurons, ...
    duration, Q0, tit)
%
% Computer simulation of a network of conductance-based single-compartment
% neurophysiological model neurons, under either deterministic
% or stochastic external current stimulation, or deterministic synaptic
% transmission, using the Hodgkin-Huxley models.
%
% NEUROSIMULATOR(ARCHITECTURE, TYPESTIMULI, TYPENEURONS, DURATION, Q0, TIT)
%
%     ARCHITECTURE is a string of characters describing the type of
%     neural architecture. Predefined architectures are chains of neurons:
%     'simplechain2', 'simplechain7', 2 neurons excited by 1 neuron and 
%     inhibited by 1 neuron: '1excite1inhib', 1 neuron excited by 2 neurons
%     and inhibited by 1 neuron: '2excite1inhib', 3x3 or 7x7 chessboard
%     architectures with only leftwards and upwards connections:
%     'simplechess3', 'simplechess7', or rightwards, leftwards, upwards
%     and downwards connections: 'reversechess3', 'reversechess7'.
%     Following the model of existing architectures, other architectures
%     can be implemented by modifying this code.
%
%     TYPESTIMULI is a string of characters describing the type of
%     electrical stimulation applied to the 1st neuron (and possibly other
%     neurons depending on the architecture). Implemented choices are:
%     'clamp', 'ramp increase x100', 'ramp decrease x100',
%     'shock', 'random shocks', 'regular shocks', and 'ramp shocks x100'.
%     Other types can be implemented by modifying this code.
%
%     TYPENEURONS is a string of characters describing the type of neurons
%     in the neural architecture: it can be either 'allExcited' (only
%     excitatory synapses), 'alternated' (every other neuron has only
%     inhibitory synapses) or 'every4' (every 4 neurons has only inhibitory
%     synapses). Other types can be implemented by modifying this code.
%
%     DURATION is the duration, in msec, of the simulation. A time step of
%     dT=0.01 msec is used.
%
%     Q0 is the value of the (initial) current used for the stimuli.
%     In case of ramps, this value can be increased or decreased.
%
%     TIT is a string of characters that is used as a root for filenames
%     of output PDF files generated by this code.
%
%     As an output, NEUROSIMULATOR generates one figure describing the
%     neural architecture, one figure per neuron showing the evolution of
%     action potential voltage, synaptic voltage, stimuli,
%     and ion channel aperture fractions m, h, n as a function of time,
%     and lastly, it generates one figure per neuron plotting the values
%     of ion channel aperture fractions m, h, n as a function of voltage.
%
% Version 1.0, New York, 20/12/2006
% (c) 2006, Piotr Mirowski,
%     Ph.D. candidate at the Courant Institute of Mathematical Sciences
%     Computer Science Department
%     New York University
%     719 Broadway, 12th Floor, New York, NY 10034, USA.
%     email: mirowski [AT] cs [DOT] nyu [DOT] edu
%
% References:
%     Charles Peskin,
%     "Lecture notes in Mathematical Aspects of Neurophysiology",
%     Courant Institute of Mathematical Sciences, New York University,
%     http://math.nyu.edu/faculty/peskin/
%     2000.
%
%     A. L. Hodkin, A. F. Huxley,
%     "A Quantitative Description of Membrane Current and its Application
%     to Conduction and Excitation in Nerve",
%     Journal of Physiology, vol. 117, pp.500-544, 1952.
%
% This program is free software; you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by
% the Free Software Foundation. This program is distributed in the hope
% that it will be useful, but WITHOUT ANY WARRANTY; without even the
% implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
% See the GNU General Public License for more details. You should have 
% received a copy of the GNU General Public License along with this 
% program; if not, write to the Free Software Foundation, Inc., 
% 59 Temple Place, Suite 330, Boston, MA 02111 USA.
%
% Please report bugs and ask for other details to:
% mirowski [AT] cs [DOT] nyu [DOT] edu
% For my personal webpage at New York University, and other projects and
% software developed, please have a look at: www.mirowski.info .

% Time sampling
% -------------
global dT
global t
dT = 0.01;
nIter = duration / dT;
time = [0:(nIter-1)] * dT;

% Grid of neurons (characterized by V, g, E, m, n, h)
% ---------------------------------------------------
global nNeurons
% Neurons are placed on a rectangular grid of size nX x nY, and they are
% indexed by their x coordinate first.
switch architecture
    case 'simplechain2'
        nX = 2;
        nY = 1;
        indStimulated = 1;
        useReverse = 0;
        typeConnections = 1;
    case 'simplechain7'
        nX = 7;
        nY = 1;
        indStimulated = 1;
        useReverse = 0;
        typeConnections = 1;
    case '1excite1inhib'
        nX = 2;
        nY = 2;
        indStimulated = [1 2];
        typeConnections = 2;
    case '2excite1inhib'
        nX = 2;
        nY = 2;
        indStimulated = [1 2 3];
        typeConnections = 3;
    case 'simplechess3'
        nX = 3;
        nY = 3;
        indStimulated = 1;
        useReverse = 0;
        typeConnections = 1;
    case 'simplechess7'
        nX = 7;
        nY = 7;
        indStimulated = 1;
        useReverse = 0;
        typeConnections = 1;
    case 'reversechess3'
        nX = 3;
        nY = 3;
        indStimulated = [1 9];
        useReverse = 1;
        typeConnections = 1;
    case 'reversechess7'
        nX = 7;
        nY = 7;
        indStimulated = [1 7 43 49];
        useReverse = 1;
        typeConnections = 1;
    otherwise, error(sprintf('Unknown architecture: %s', architecture));
end
nNeurons = nX * nY;
allV = ones(nNeurons, nIter);
allM = ones(nNeurons, nIter);
allH = ones(nNeurons, nIter);
allN = ones(nNeurons, nIter);
allE = ones(nNeurons, nIter);
allG = ones(nNeurons, nIter);
stimuli = zeros(1, nIter);
Q_applied = zeros(nNeurons, nIter);

% Type of excitatory/inhibitory neurons
% -------------------------------------
global E_reverse
% Values of EPSP and IPSP were chosen so that an IPSP corresponds
% to an excitation of -5mV, and an EPSP to an excitation of 8mV
E_excite = -60;
E_inhib = -73;
E_reverse = E_excite * ones(nNeurons, 1);
switch typeNeurons
    case 'allExcited'
    case 'alternated'
        E_reverse(2:2:nNeurons) = E_inhib;
    case 'every4'
        E_reverse(2:4:nNeurons) = E_inhib;
    case 'every10'
        E_reverse(3:10:nNeurons) = E_inhib;
    otherwise, error(sprintf('Unknown type of neurons: %s', typeNeurons));
end

% Synapses
% --------
global synapses
synapses = zeros(nNeurons);
if typeConnections == 1
    % Chessboard-like connections, only horizontal and vertical
    for y = 1:nY
        for x = 1:nX
            i = x + (y - 1) * nX;
            if (x > 1) & (useReverse == 1)
                synapses(i-1, i) = 1;
            end
            if (x < nX)
                synapses(i+1, i) = 1;
            end
            if (nY > 1) & (y > 1) & (useReverse == 1)
                synapses(i-nX, i) = 1;
            end
            if (nY > 1) & (y < nY)
                synapses(i+nX, i) = 1;
            end
        end
    end
else
    % Excitatory and inhibitory neurons interconnected
    if typeConnections == 3
        synapses(4, 1:3) = 1;
    else
        synapses([3:4], [1:2]) = 1;
    end
end

% Type of stimuli
% ---------------
switch typeStimuli
    case 'clamp'
        Q_applied(indStimulated, :) = Q0;
        stimuli(:) = 1;
    case 'ramp increase x100'
        for j = indStimulated
            Q_applied(j, :) = Q0 * (1 + 99*[1:nIter]/nIter);
        end
        stimuli(:) = 1;
    case 'ramp decrease x100'
        for j = indStimulated
            Q_applied(j, :) = Q0 * (1 - 0.99 * [1:nIter]/nIter);
        end
        stimuli(:) = 1;
    case 'shock'
        Q_applied(indStimulated, 1) = Q0;
        stimuli(1) = 1;
    case 'random shocks'
        for j = indStimulated
            shocks = round(rand(1, dT * nIter / 10) * nIter);
            Q_applied(j, shocks) = Q0;
        end
        stimuli(shocks) = 1;
    case 'regular shocks'
        shocks = 1:round(dT*nIter):nIter;
        Q_applied(indStimulated, shocks) = Q0;
        stimuli(shocks) = 1;
    case 'ramp shocks x100'
        shocks = 1:round(dT*nIter):nIter;
        for j = indStimulated
            Q_applied(j, shocks) = Q0 * (1 + 99 * shocks/nIter);
        end
        stimuli(shocks) = 1;
    otherwise, error(sprintf('Unknown stimuli: %s', typeStimuli));
end

% Parameters
% ----------
global C
global g_Na
global E_Na
global g_K
global E_K
global g_L
global E_L
global E_rest
C = 1;
E_Na = 45;
E_K = -82;
E_L = -59;
E_rest = -70;
g_Na = 120;
g_K = 36;
g_L = 0.3;

% Initialization
% --------------
E = ones(nNeurons, 1) * E_rest;
G_syn = zeros(nNeurons, 1);
for k = 1:10
    % Calcium and potassium channels are closed
    % Compute the equivalent conductivity and reversal potential
    m = Alpha_m(E) ./ (Alpha_m(E) + Beta_m(E));
    h = Alpha_h(E) ./ (Alpha_h(E) + Beta_h(E));
    n = Alpha_n(E) ./ (Alpha_n(E) + Beta_n(E));
    [g, E] = UpdateGE(m, h, n, G_syn, E);
end
E_rest = E(1);
disp('After 10 iterations:');
disp(sprintf('E_rest=%gmV, m_inf=%g, n_inf=%g, h_inf=%g', ...
    E_rest, m(1), h(1), n(1)));
% All neurons are at their rest potential
V = ones(nNeurons, 1) * E_rest;
dV = zeros(nNeurons, 1);

% Iteration
% ---------
for t = 1:nIter
    allV(:, t) = V;
    allH(:, t) = h;
    allM(:, t) = m;
    allN(:, t) = n;
    allE(:, t) = E;
    allG(:, t) = G_syn;
    [V, dV, g, E, m, h, n, G_syn] = ...
        Apply_HodgkinHuxley(V, dV, g, E, m, h, n, Q_applied(:, t), G_syn);
end

% Compute frequency of firing
% ---------------------------
spikes = cell(nNeurons, 1);
diffM = diff(allM');
M = max(diffM);
m = min(diffM);
diffM2 = zeros(nNeurons, nIter-1);
for k = 1:nNeurons
    diffM2(k, :) = round((diffM(:, k)' - m(k)) / (M(k) - m(k)));
end
diffM2 = (diffM2 == 1);
diffM2 = diffM2 .* (allM(:, 2:end) > 0.2);
diffM = diff(diffM2')';
for k = 1:nNeurons
    ind = find(diffM(k, :) == 1);
    if ~isempty(ind)
        spikes{k} = ind;
    end
end

% Plot results
% ------------
Plot_Architecture(nX, nY, synapses, Q_applied, tit);
Plot_Spikes(nX, nY, synapses, Q_applied, spikes, tit);
% for k = 1:nNeurons
%     Plot_Neuron(k, allV, allE, allM, allN, allH, allG, time, Q_applied, ...
%         Q0, typeStimuli, spikes, tit);
%     Plot_Planes(k, allV, allM, allN, allH, Q_applied, ...
%         Q0, typeStimuli, tit);
% end
